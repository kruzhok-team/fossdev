# Создаем Docker контейнер на базе дистрибутива Linux и настраиваем там рабочее окружение для проекта Python

Docker — популярная технология контейнеризации, появившаяся в 2013 году. Тогда одноименная компания предложила способ виртуализации ОС, при котором код приложения, среда запуска, библиотеки и зависимости упаковываются в единую «капсулу» — контейнер Docker.

Одной из реализаций идеи о разделении ресурсов стали Croot jail и операция Chroot, которые появились в 1979 году в UNIX версии 7. С помощью Chroot jail процесс и его дочерние элементы изолировались от основной ОС. Docker фактически можно считать продолжением этой идеи. Но корневой процесс мог выходить из chroot, а механизмов безопасности на тот момент еще не придумали.

Спустя 20 лет появился FreeBSD Jail — механизм виртуализации, позволяющий внутри одной ОС использовать несколько изолированных систем, которые назвали тюрьмами. Далее технологии контейнеризации развивались стремительно. В 2001 году появился Linux VServer, который использовал chroot-подобную утилиту и применялся для безопасного разделения ресурсов. Каждый раздел назывался «контекстом безопасности», а виртуализированная система внутри него — виртуальным частным сервером.

В 2005 году представили OpenVZ с виртуализацией на уровне ОС, благодаря которой усовершенствовалась технология изоляции. Но был и серьезный недостаток: у контейнеров и хоста была одна архитектура и версия ядра. Если требовалась другая, возникали проблемы.

В 2007 году компания Google представила функцию CGroups, ограничивающую использование ресурсов (CPU, ROM, дисковый ввод-вывод, сеть и т. д.) на уровне групп процессов. Спустя год выпустили Linux Containers (LXC), который имел много общего с OpenVZ и Linux-VServer, но использовал механизмы namespaces и CGroups из Linux-ядра вместо сторонних механизмов, внедряемых в ядро с помощью патчей.

В 2013 году компания Cloud Foundry создала Warden. Новая утилитапредназначалась для запуска приложений, которые получают все свои зависимости от частей ПО, называемых buildpacks. Контейнеры Warden обычно имеют два слоя: слой только для чтения с корневой файловой системой ОС и неперсистентный слой чтения/записи самого приложения и его зависимостей. В 2013 году на рынке появился и Docker.

#  Что такое Docker
Docker — это платформа контейнеризации с открытым исходным кодом, с помощью которой можно автоматизировать создание приложений, их доставку и управление. Платформа позволяет быстрее тестировать и выкладывать приложения, запускать на одной машине требуемое количество контейнеров.

>Благодаря контейнеризации и использованию Docker разработчики больше не задумываются о том, в какой среде будет функционировать их приложение и будут ли в этой в среде необходимые для тестирования опции и зависимости. Достаточно упаковать приложение со всеми зависимостями и процессами в контейнер, чтобы запускать в любых системах: Linux, Windows и macOS. Платформа Docker позволила отделить приложения от инфраструктуры. Контейнеры не зависят от базовой инфраструктуры, их можно легко перемещать между облачной и локальной инфраструктурами.
>У контейнеризации и виртуализации есть сходство, но есть и различия. Виртуализация напоминает отдельный компьютер со своим оборудованием и ОС, внутри которого можно запустить еще одну ОС. А контейнеризация предполагает, что виртуальная среда запускается из ядра ОС, не предусматривает виртуализации оборудования и снижает потребление ресурсов.

В подавляющем большинстве контейнеров на данный момент используются минимальные образы Linux. Одним из таких примеров является проект Alphine. 

Подобные миниатюрные сборки ОС позволяют организовать удобную среду для мониторинга и управления приложениями. Помимо прочего ОС Linux обладает большим набором эффективных и нетребовательных к вычислительным ресурсам инструментов для решения широкого спектра задач. Это и является основной причиной её выбора при разработке отказоустойчивых, гибких и высоконагруженных решений. 
Программист, конечно может запустить код на Python в Docker контейнере без использования образа с ОС, но в случае возникновения ошибки в процессе работы программы, или сбоя в работе контейнера, зафиксировать его и определить причину сбоя будет достаточно сложно, как и корректно перезапустить работу контейнера избежав потери данных. 

Подробней познакомимся с тем, что такое контейнеры и Docker. 


## Что такое контейнеризация
Это технология, которая помогает сделать приложения более безопасными, облегчают их развёртывание и улучшают возможности по их масштабированию. Рост и развитие технологий контейнеризации можно считать одним из важнейших трендов современности. 

Технологии контейнеризации приложений нашли широкое применение в сферах разработки ПО и анализа данных. Несколько контейнеров могут объединяться в сеть и совместно выполнять свою задачу. Например, Контейнер №1 содержит код приложения: Linux, Python, Flask, SQLAlchemy. 
Контейнер №2 содержит базу данных и выполняет обработку внешних запросов к данным находящимся в базе данных. 
Контейнер №3, выполняет мониторинг и анализ данных, формирует отчетность на основе данных из базы данных в контейнере №2 и предоставляет пользователям контейнера №1. 

Таким образом, каждый контейнер решает отдельную задачу. Физически контейнеры могут находиться в разных помещениях, городах и даже странах. Это и есть возможность масштабирования приложений. 

## Контейнер Docker обладает следующими характеристиками:
- В нём можно хранить различные ресурсы: скрипты, исходный код, базу данных, наборы тестов, веб-формы, модели данных, и т.д. Ресурсы могут располагаться как в контейнере, так и за его пределами (через удаленный доступ в сети, либо используя общее место хранения данных – "Volume"). Его можно переносить. Контейнер Docker можно использовать на локальном ПК, на ПК находящемся в рабочей сети, на удаленном облачном сервере (Яндекс.Облако, AWS, Google.Cloud и др). 
- Удобный и гибкий интерфейс обращения к его содержимому. Механизмы, позволяющие контейнеру взаимодействовать с внешним миром. Например, у контейнера есть порты, которые можно открывать для того, чтобы к приложению, работающему в контейнере, можно было бы обращаться из браузера или по протоколу SSH. Работать с контейнером можно и средствами командной строки.
- Образ контейнера, хранится в специальном репозитории (Docker-hub). Если вам нужен некий готовый контейнер, вы можете загрузить из репозитория соответствующий образ, и, используя его, этот контейнер создать.

## Особенности контейнеров

Важнейшая особенность контейнеров — их сравнительно короткий жизненный цикл. Любой контейнер можно остановить, перезапустить или уничтожить, если это необходимо. Данные, которые содержатся в контейнере, при этом тоже пропадут. Так выработалось правило проектирования приложений: не хранить важные данные в контейнере. Такой подход называют Stateless.

- Объем контейнеров измеряется в мегабайтах, поскольку в них упаковывают лишь те процессы и зависимости ОС, которые необходимы для выполнения кода. Легковесные контейнеры быстро запускаются и экономят место на диске.

- Один контейнер соответствует одному запущенному процессу. Отключение отдельного контейнера для отладки или обновления никак не помешает нормальной работе всего приложения.

- Контейнеризация обеспечивает надежную изоляцию процессов и повышает уровень безопасности систем. Приложения, которые работают внутри контейнера, не имеют доступа к основной ОС и не могут на неё влиять.

- Благодаря контейнерам можно автоматизировать развертывание приложений на разных хостах.

- Использование контейнеров позволяет перейти с монолита на микросервисную архитектуру. За счет этого ускоряется разработка новой функциональности, поскольку нет опасений, что изменения в одной компоненте затронут всю остальную систему.

- С точки зрения эффективности контейнеры котируются выше виртуальных машин. На одинаковом оборудовании можно запустить большое количество контейнеров, тогда как виртуальная машина будет в разы меньше. Это важно при использовании облачной инфраструктуры — потребуется меньше ресурсов.

Давайте разберемся в чем отличие образа и контейнера – если сказать в двух словах, то Docker контейнер это запущенный (активные) образ. Образ в свою очередь это то что представляет собой функциональную часть одна или несколько программ, скриптов, данных и т.д., то что будет выполняться при запуске образа в контейнере. Образы достаточно просто создаются инструментами Docker. На базовом уровне, контейнер представляет собой набор инструкций, который выполняется на некоем процессоре, обрабатывая какие-то данные.

## Контейнер это 

Во время выполнения контейнера Docker внутри него обычно выполняется какая-то программа. Она выполняет в контейнере некие действия, тем самым приносит пользу, выполняя определенные действия для решения своей задачи.
Например, код, который работает в контейнере Docker, возможно, отправил на ваш компьютер тот текст, который вы сейчас читаете. Вполне возможно и то, что именно код, выполняющийся в контейнере Docker, принимает голосовые команды, которые вы проговариваете "умной колонке с Алисой" или голосовому ассистенту в смартфоне или ноутбуке и преобразует их в инструкции для ещё каких-нибудь программ, запущенных в других контейнерах.
Благодаря использованию Docker можно, на одном и том же компьютере, одновременно управлять набором контейнеров, запускать, останавливать и удалять. 

## Концепции Docker

Предшественниками контейнеров Docker были виртуальные машины. Виртуальная машина, как и контейнер, изолирует от внешней среды приложение и его зависимости. Однако контейнеры Docker обладают преимуществами перед виртуальными машинами. Так, они потребляют меньше ресурсов, их очень легко переносить, они быстрее запускаются и приходят в работоспособное состояние. 

## Образ контейнера Docker

Выше мы уже говорили об «образах». Что это такое? Хороший вопрос. То, что в терминологии Docker называется «образом». Образы контейнеров Docker можно сравнить с чертежами, классом из ООП, или с пресс-формой для чеканки монет. Образы это неизменные шаблоны, которые используются для создания одинаковых контейнеров. В образе контейнера Docker содержится образ базовой операционной системы, код приложения, библиотеки, от которого оно зависит. Всё это скомпоновано в виде единой сущности, на основе которой можно создать контейнер.

## Чем отличаются «докер-контейнер» и «докер-образ»

В Docker контейнер и образ — это две разные вещи с разными целями:
Docker образ это шаблон, определяющий приложение и его зависимости. Это схема или снимок приложения, доступный только для чтения, который можно использовать для создания контейнеров Docker. Образ создается путем запуска файла Dockerfile, в котором указывается используемый базовый образ, любые зависимости, которые необходимо установить, а также любая пользовательская конфигурация или код. После создания образа его можно распространять и делиться с другими.

Docker контейнер это работающий экземпляр образа. Его можно рассматривать как легкий автономный исполняемый пакет, включающий все необходимое для запуска приложения, включая программный код, среду выполнения, системные инструменты, библиотеки и настройки. Когда контейнер запускается, в верхнюю часть образа добавляется новый доступный для записи слой, позволяющий вносить изменения в работающее приложение. Несколько контейнеров могут быть созданы из одного и того же образа, каждый со своим отдельным записываемым слоем.

Проще говоря, образ – это статический файл, который включает в себя все необходимое для запуска приложения, а контейнер – это работающий экземпляр образа, который можно изменять и с которым можно взаимодействовать.

### Установка Докера в Windows
1. Перейдите на веб-сайт Docker и загрузите установщик Docker Desktop для Windows.
2. Запустите программу установки и следуйте инструкциям для завершения установки.
3. После установки Docker Desktop должен запуститься автоматически. Если это не так, вы можете запустить его из меню «Пуск».
4. После запуска Docker Desktop вы можете использовать его для создания и запуска контейнеров Docker.
### Установка Докера в Linux
Точные шаги по установке Docker в Linux зависят от используемого вами дистрибутива. Вот основные шаги для Ubuntu:
1. Откройте терминал и выполните следующую команду, чтобы установить зависимости Docker:

**`sudo apt-get update`** 

**`sudo apt-get install apt-transport-https ca-certificates curl software-properties-common`**

2. Добавьте ключ Docker GPG в свою систему:
**`curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -`**

3. Добавьте репозиторий Docker в ваши источники APT:
**`sudo add-apt-repository " deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable "`**

4. Обновите индекс пакета APT и установите Docker:

**`sudo apt-get update`**
**`sudo apt-get install docker-ce`** 

5. После установки Docker должен быть запущен в вашей системе. Вы можете проверить это, выполнив следующую команду:

**`sudo docker run hello-world`** 

Это загрузит тестовый образ Docker и запустит его в контейнере. Это основной процесс установки Docker в Linux. Точные шаги могут различаться в зависимости от используемого дистрибутива и версии.
Здесь мы исходим из предположения, в соответствии с которым используется образ Docker, основанный на Unix-подобной ОС. Конечно, тут можно воспользоваться и образом, основанным на Windows, но использование Windows это менее распространённая практика, работать с такими образами сложнее. В результате, если у вас есть такая возможность, рекомендуем использовать Unix. Однако, для выполнения практических примеров можно использовать в любую ОС. Поскольку мы будем использовать только базовые команды Docker в окне терминала (консоли). 

###Быстрый Старт 

Чтобы запустить контейнер Docker, вы можете выполнить следующие общие шаги:

Извлеките образ Docker. Если вы еще этого не сделали, вам потребуется извлечь образ Docker, который вы хотите запустить, из реестра Docker, такого как Docker Hub. Вы можете сделать это с помощью команды **`docker pull`**, за которой следует имя и тег образа.

**`docker pull <image-name>:<tag>`**

Например, чтобы получить официальный образ nginx, вы можете использовать:

**`docker pull nginx:latest`**
 
Запустите контейнер Docker: получив образ, вы можете запустить контейнер, выполнив команду запуска docker, за которой следует имя образа и любые дополнительные параметры, которые вы хотите указать.

**`docker run [OPTIONS] <image-name>`**

Например, чтобы запустить контейнер из образа nginx, вы можете использовать:

**`docker run -p 8080:80 nginx:latest`**

В результате выполнения этой команды у нас запустится контейнер с образом nginx. 
  Следует отметить что мы указали параметр [-p 8080:80] для предоставления доступа внешних приложений к нашему запущенному контейнеру используя порт 8080. Чтоб в этом убедиться откроем браузер и введем следующий адрес (http://localhost:8080/). Нам откроется приветственная HTML страница nginx сообщающая о том, что веб-сервер nginx успешно запустился.     
 
В данном случае мы указали порт 8080 для того чтоб достучаться до 80 порта внутри нашего контейнера, это очень полезный параметр. Ведь если нам потребуется запустить несколько контейнеров, внутри которых используется стандартный порт например 80, то мы не сможем использовать его для отдельного обращения к каждому контейнеру. 
 
Эта команда запускает новый контейнер из образа `nginx:latest` и сопоставляет порт 80 в контейнере с портом 8080 на хост-компьютере. Параметр `-p` указывает сопоставление портов.
Убедитесь, что контейнер работает, для этого вы можете использовать команду: `docker ps`.

**docker ps**

Эта команда выводит список всех запущенных контейнеров. Если вы не видите свой контейнер в списке, обязательно используйте команду `docker ps -a`, чтобы увидеть все контейнеры (включая остановленные).
Чтобы остановить работающий контейнер, вы можете использовать команду docker stop, за которой следует идентификатор или имя контейнера.

**`docker stop <container-id>`**

Например, чтобы остановить контейнер с идентификатором abc123, вы можете использовать:

**`docker stop abc123`**

Это основные шаги для запуска контейнера Docker. Вы можете найти более расширенное использование Docker с дополнительными параметрами и конфигурациями в документации Docker.

**Какие параметры есть у команды `docker run`?**

Команда **`docker run`** имеет ряд опций, которые можно использовать для настройки поведения контейнера во время выполнения. Вот некоторые из наиболее часто используемых опций:
`-d` или `--detach`: Запуск контейнера в фоновом режиме (режим отсоединения).
`-p` или `--publish`: Публиковать порт(ы) контейнера на хост-машине.
`-v` или `--volume`: Смонтировать каталог хоста в качестве тома данных в контейнере.
`-e` или `--env`: Установить переменные окружения для контейнера.
`--name`: присвоить имя контейнеру.
`--restart`: Задать политику перезапуска для контейнера.
`-it` или `--interactive` и `--tty`: Запустить интерактивный сеанс с контейнером и выделить псевдо-TTY.
`--rm`: Автоматически удалять контейнер при выходе из него.
`--network`: Подключить контейнер к сети.
Вот пример команды docker run, которая использует несколько из этих опций для запуска контейнера с определенным именем, переменной окружения и сопоставлением портов:

###Файл Dockerfile

Познакомившись с таким понятием как "образ Docker" посмотрим как они создаются и из чего состоят. Для этого нам нужно познакомиться с файлом "Dockerfile". Dockerfile может быть простым, например состоять из одной сроки: 

``` dockefile
FROM ubuntu:18.04
```

Он содержит набор инструкций, следуя которым Docker будет собирать образ. Этот файл содержит описание базового образа, который будет представлять собой исходный слой образа. Среди популярных официальных базовых образов можно отметить: 
•	python (https://hub.docker.com/_/python), 
•	ubuntu (https://hub.docker.com/_/ubuntu), 
•	alpine (https://hub.docker.com/_/alpine). 

Ознакомиться с актуальным списком образов можно на сайте docker hub: `https://hub.docker.com/`

 
Для начала приведём список инструкций Dockerfile с краткими комментариями:

**FROM** – задаёт базовый (родительский) образ.

**LABEL** – описывает метаданные. Например, информация о том, кто создал образ, его почта и ссылки на справочную информацию.

**ENV** – устанавливает постоянные переменные среды.

**RUN** – выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов.

**COPY** – копирует в контейнер файлы и папки.

**ADD** – копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы.

**CMD** – описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция `CMD`.

**WORKDIR** – задаёт рабочую директорию для следующей инструкции.

**ARG** – задаёт переменные для передачи Docker во время сборки образа.

**ENTRYPOINT** – предоставляет команду с аргументами для вызова во время выполнения контейнера. Аргументы не переопределяются.

**EXPOSE** – указывает на необходимость открыть порт чтоб предоставить возможность приложениям из контейнера обращаться к внешним ресурсам, а также предоставить возможность внешним клиентам подключаться к ресурсам в контейнере.

**VOLUME** – создаёт точку монтирования для работы с постоянным хранилищем.
Слои в итоговом образе создают только инструкции `FROM`, `RUN`, `COPY`, и `ADD`. Другие инструкции отвечают за настройку компонентов, различные  действия с файлами проекта, описывают метаданные, а также сообщают Docker о том, что во время работы контейнера нужно выполнить какие-либо действия. Например, открыть сетевой порт для организации доступа к внешним приложениям или выполнить команду для решения задачи.

Файл `Dockerfile` должен начинаться с инструкции `FROM`, или с инструкции `ARG`, за которой идёт инструкция `FROM`. Ключевое слово `FROM` сообщает Docker о том, чтобы при сборке образа использовался бы базовый образ, который соответствует предоставленному имени и тегу. Базовый образ, кроме того, ещё называют родительским образом.

В этом примере базовый образ хранится в репозитории ubuntu (https://hub.docker.com/_/ubuntu). Ubuntu это название официального репозитория Docker, предоставляющего базовую версию популярной ОС семейства Linux.

Обратите внимание на то, что рассматриваемый Dockerfile включает в себя тег 18.04, уточняющий, какую версию ОС нужно использовать. Именно этот образ ОС и будет загружен при сборке нашего образа. Если не использовать тег (18.04), тогда Docker будет использовать самый свежий образ из репозитория (они используют тег latest). Чтоб избежать случайных сбоев из-за конфликта версий ОС, рекомендуется указывать актуальную версию образа/библиотеки/модуля.

При первом запуске сборки образа используя Dockerfile, Docker загрузит слои, определяемые образом ubuntu. Их можно представить наложенными друг на друга. Каждый следующий слой представляет собой файл, описывающий отличия образа в сравнении с тем его состоянием, в котором он был после добавления в него предыдущего слоя.

При создании контейнера слой, в который можно вносить изменения, добавляется поверх всех остальных слоёв. Данные, находящиеся в остальных слоях, можно только читать.
 
###Структура контейнера

Docker, ради эффективности, использует стратегию копирования при записи. Если слой в образе существует на предыдущем уровне и какому-то слою нужно произвести чтение данных из него, Docker использует существующий файл. При этом ничего загружать не нужно.

Когда образ выполняется, если слой нужно модифицировать средствами контейнера, то соответствующий файл копируется в самый верхний, изменяемый слой. Для того чтобы узнать подробности о стратегии копирования при записи, посмотрите материалы в документации Docker (https://docs.docker.com/storage/storagedriver/).
Продолжим рассмотрение инструкций, которые используются в Dockerfile, приведя пример такого файла с более сложной структурой.

###Более сложный Dockerfile

Хотя файл Dockerfile, который мы только что рассмотрели, получился аккуратным и понятным, он устроен слишком просто, в нём используется всего одна инструкция. Кроме того, там нет инструкций, вызываемых во время выполнения контейнера. Взглянем на ещё один файл, который собирает маленький образ. В нём имеются механизмы, определяющие команды, вызываемые во время выполнения контейнера.

```Dockerfile
FROM python:3.7.2-alpine3.8
LABEL maintainer="author_dockerfile@mail.ru"
ENV ADMIN="Sergey"
RUN apk update && apk upgrade && apk add bash
COPY . ./app
RUN ["mkdir", "/directory"]
CMD ["python", "./my_script.py"]
```

Возможно, на первый взгляд этот файл может показаться довольно сложным. Поэтому давайте с ним разберёмся. Базой этого образа является официальный образ Python с тегом `3.7.2-alpine3.8`. Проанализировав этот код можно увидеть, что данный базовый образ включает в себя Linux, Python, и, по большому счёту, этим его состав и ограничивается. Образы ОС Alpine весьма популярны в мире Docker. Дело в том, что они отличаются маленькими размерами, высокой скоростью работы и безопасностью. Однако образы Alpine не отличаются широкими возможностями, характерными для обычных операционных систем. Поэтому для того, чтобы собрать на основе такого образа что-то полезное, создателю образа нужно установить в него необходимые ему пакеты.

### Инструкция LABEL

Инструкция LABEL (метка) позволяет добавлять в образ метаданные. В случае с рассматриваемым сейчас файлом, она включает в себя контактные сведения создателя образа. Объявление меток не замедляет процесс сборки образа и не увеличивает его размер. Они лишь содержат в себе полезную информацию об образе Docker, поэтому их рекомендуется включать в файл. Подробности о работе с метаданными в Dockerfile можно прочитать здесь.

### Инструкция ENV. Окружающая среда

Инструкция `ENV` позволяет задавать постоянные переменные среды, которые будут доступны в контейнере во время его выполнения. В предыдущем примере после создания контейнера можно пользоваться переменной ADMIN.

Инструкция `ENV` хорошо подходит для задания констант. Если вы используете некое значение в Dockerfile несколько раз, скажем, при описании команд, выполняющихся в контейнере, и подозреваете, что, возможно, вам когда-нибудь придётся сменить его на другое, его имеет смысл записать в подобную константу. 

Надо отметить, что в файлах Dockerfile часто существуют разные способы решения одних и тех же задач. Что именно использовать это вопрос, на решение которого влияет стремление к соблюдению принятых в среде Docker методов работы, к обеспечению прозрачности решения и его высокой производительности. Например, инструкции `RUN`, `CMD` и `ENTRYPOINT` служат разным целям, но все они используются для выполнения команд.

### Инструкция RUN

Инструкция RUN позволяет создать слой во время сборки образа. После её выполнения в образ добавляется новый слой, его состояние фиксируется. Инструкция RUN часто используется для установки в образы дополнительных пакетов. В предыдущем примере инструкция RUN apk update && apk upgrade сообщает Docker о том, что системе нужно обновить пакеты из базового образа. Вслед за этими двумя командами идёт команда && apk add bash, указывающая на то, что в образ нужно установить bash.

То, что в командах выглядит как apk это сокращение от Alpine Linux package manager (менеджер пакетов Alpine Linux). Если вы используете базовый образ какой-то другой ОС семейства Linux, тогда вам, например, при использовании Ubuntu, для установки пакетов может понадобиться команда вида RUN apt-get. Позже мы поговорим о других способах установки пакетов.

Инструкция `RUN` и схожие с ней инструкции — такие, как `CMD` и `ENTRYPOINT`, могут быть использованы либо в exec-форме, либо в shell-форме. Exec-форма использует синтаксис, напоминающий описание JSON-массива. Например, это может выглядеть так: `RUN ["my_executable", "my_first_param1", "my_second_param2"]`.
В предыдущем примере мы использовали shell-форму инструкции `RUN` в таком виде: `RUN apk update && apk upgrade && apk add bash`.
Позже в нашем Dockerfile использована exec-форма инструкции `RUN`, в виде `RUN ["mkdir", "/a_directory"]` для создания директории. При этом, используя инструкцию в такой форме, нужно помнить о необходимости оформления строк с помощью двойных кавычек, как это принято в формате JSON.

### Инструкция COPY

Инструкция COPY представлена в нашем файле так: `COPY . ./app`. Она сообщает Docker о том, что нужно взять файлы и папки из локального контекста сборки и добавить их в текущую рабочую директорию образа. Если целевая директория не существует, эта инструкция её создаст.

### Инструкция ADD

Инструкция ADD позволяет решать те же задачи, что и COPY, но с ней связана ещё пара вариантов использования. Так, с помощью этой инструкции можно добавлять в контейнер файлы, загруженные из удалённых источников, а также распаковывать локальные .tar-файлы.

В этом примере инструкция `ADD` была использована для копирования файла, доступного по URL, в директорию контейнера `my_app_directory`. Надо отметить, однако, что документация Docker не рекомендует использование подобных файлов, полученных по URL, так как удалить их нельзя, и так как они увеличивают размер образа.
Кроме того, документация предлагает везде, где это возможно, вместо инструкции `ADD` использовать инструкцию `COPY` для того, чтобы сделать файлы Dockerfile понятнее. Полагаю, команде разработчиков Docker стоило бы объединить `ADD` и `COPY` в одну инструкцию для того, чтобы тем, кто создаёт образы, не приходилось бы помнить слишком много инструкций.

Обратите внимание на то, что инструкция `ADD` содержит символ разрыва строки `— \`. Такие символы используются для улучшения читабельности длинных команд путём разбиения их на несколько строк.

### Инструкция CMD

Инструкция CMD предоставляет Docker команду, которую нужно выполнить при запуске контейнера. Результаты выполнения этой команды не добавляются в образ во время его сборки. В нашем примере с помощью этой команды запускается скрипт `my_script.py` во время выполнения контейнера. Вот ещё кое-что, что нужно знать об инструкции `CMD`:
1.	В одном файле Dockerfile может присутствовать лишь одна инструкция `CMD`. Если в файле есть несколько таких инструкций, система проигнорирует все кроме последней.
2.	Инструкция CMD может иметь exec-форму. Если в эту инструкцию не входит упоминание исполняемого файла, тогда в файле должна присутствовать инструкция ENTRYPOINT. В таком случае обе эти инструкции должны быть представлены в формате JSON.
3.	Аргументы командной строки, передаваемые docker run, переопределяют аргументы, предоставленные инструкции `CMD` в Dockerfile.
Рассмотрим ещё один файл Dockerfile, в котором будут использованы некоторые новые команды.

``` Dockerfike
FROM python:3.7.2-alpine3.8
LABEL maintainer="jeffmshale@gmail.com"
# Устанавливаем зависимости
RUN apk add --update git
# Задаём текущую рабочую директорию
WORKDIR /usr/src/my_app_directory
# Копируем код из локального контекста в рабочую директорию образа
COPY . .
# Задаём значение по умолчанию для переменной
ARG my_var=my_default_value
# Настраиваем команду, которая должна быть запущена в контейнере во время его выполнения
ENTRYPOINT ["python", "./app/my_script.py", "my_var"]
# Открываем порты
EXPOSE 8000
# Создаём том для хранения данных
VOLUME /my_volume
```

В этом примере, кроме прочего, вы можете видеть комментарии, которые начинаются с символа `#`.
Одно из основных действий, выполняемых средствами Dockerfile — это установка пакетов. Как уже было сказано, существуют различные способы установки пакетов с помощью инструкции `RUN`.

Пакеты в образ Alpine Docker можно устанавливать с помощью apk. Для этого, как мы уже говорили, применяется команда вида `RUN apk update && apk upgrade && apk add bash`.

Кроме того, пакеты Python в образ можно устанавливать с помощью pip, wheel и conda. Если речь идёт не о Python, а о других языках программирования, то при подготовке соответствующих образов могут использоваться и другие менеджеры пакетов.

При этом для того, чтобы установка была бы возможной, нижележащий слой должен предоставить слою, в который выполняется установка пакетов, подходящий менеджер пакетов. Поэтому если вы столкнулись с проблемами при установке пакетов, убедитесь в том, что менеджер пакетов установлен до того, как вы попытаетесь им воспользоваться.

Например, инструкцию RUN в Dockerfile можно использовать для установки списка пакетов с помощью pip. Если вы так поступаете — объедините все команды в одну инструкцию и разделите её символами разрыва строки с помощью символа `\`. Благодаря такому подходу файлы будут выглядеть аккуратно и это приведёт к добавлению в образ меньшего количества слоёв, чем было бы добавлено при использовании нескольких инструкций RUN.

Кроме того, для установки нескольких пакетов можно поступить и по-другому. Их можно перечислить в файле и передать менеджеру пакетов этот файл с помощью RUN. Обычно таким файлам дают имя requirements.txt.

## Инструкция WORKDIR

Инструкция WORKDIR позволяет изменить рабочую директорию контейнера. С этой директорией работают инструкции COPY, ADD, RUN, CMD и ENTRYPOINT, идущие за WORKDIR. Вот некоторые особенности, касающиеся этой инструкции:
- лучше устанавливать с помощью WORKDIR абсолютные пути к папкам, а не перемещаться по файловой системе с помощью команд cd в Dockerfile;
- инструкция WORKDIR автоматически создаёт директорию в том случае, если она не существует;
- можно использовать несколько инструкций WORKDIR. Если таким инструкциям предоставляются относительные пути, то каждая из них меняет текущую рабочую директорию.

## Инструкция ARG

Инструкция ARG позволяет задать переменную, значение которой можно передать из командной строки в образ во время его сборки. Значение для переменной по умолчанию можно представить в Dockerfile. Например: ARG my_var=my_default_value.
В отличие от ENV-переменных, ARG-переменные недоступны во время выполнения контейнера. Однако ARG-переменные можно использовать для задания значений по умолчанию для ENV-переменных из командной строки в процессе сборки образа. А ENV-переменные уже будут доступны в контейнере во время его выполнения. Подробности о такой методике работы с переменными можно почитать здесь.
## Инструкция ENTRYPOINT

Инструкция ENTRYPOINT позволяет задавать команду с аргументами, которая должна выполняться при запуске контейнера. Она похожа на команду CMD, но параметры, задаваемые в ENTRYPOINT, не перезаписываются в том случае, если контейнер запускают с параметрами командной строки.

Вместо этого аргументы командной строки, передаваемые в конструкции вида docker run my_image_name, добавляются к аргументам, задаваемым инструкцией ENTRYPOINT. Например, после выполнения команды вида docker run my_image bash аргумент bash добавится в конец списка аргументов, заданных с помощью ENTRYPOINT. Готовя Dockerfile, не забудьте об инструкции CMD или ENTRYPOINT.

В документации к Docker есть несколько рекомендаций, касающихся того, какую инструкцию, CMD или ENTRYPOINT, стоит выбрать в качестве инструмента для выполнения команд при запуске контейнера:

Если при каждом запуске контейнера нужно выполнять одну и ту же команду используйте ENTRYPOINT.
Если контейнер будет использоваться в роли приложения используйте ENTRYPOINT.
Если вы знаете, что при запуске контейнера вам понадобится передавать ему аргументы, которые могут перезаписывать аргументы, указанные в Dockerfile, используйте CMD.

В нашем примере использование инструкции ENTRYPOINT ["python", "my_script.py", "my_var"] приводит к тому, что контейнер, при запуске, запускает Python-скрипт my_script.py с аргументом my_var. Значение, представленное my_var, потом можно использовать в скрипте с помощью argparse. Обратите внимание на то, что в Dockerfile переменной my_var, до её использования, назначено значение по умолчанию с помощью ARG. В результате, если при запуске контейнера ему не передали соответствующее значение, будет применено значение по умолчанию.
Документация Docker рекомендует использовать exec-форму ENTRYPOINT: ENTRYPOINT ["executable", "param1", "param2"].

## Инструкция EXPOSE
Инструкция EXPOSE указывает на то, какие порты планируется открыть для того, чтобы через них можно было бы связаться с работающим контейнером. Эта инструкция не открывает порты. Она, скорее, играет роль документации к образу, средством общения того, кто собирает образ, и того, кто запускает контейнер.
Для того чтобы открыть порт (или порты) и настроить перенаправление портов, нужно выполнить команду docker run с ключом -p. Если использовать ключ в виде -P (с заглавной буквой P), то открыты будут все порты, указанные в инструкции EXPOSE.

## Инструкция VOLUME
Инструкция VOLUME позволяет указать место, которое контейнер будет использовать для постоянного хранения файлов и для работы с такими файлами. Об этом мы ещё поговорим.

Теперь вы знаете дюжину инструкций, применяемых при создании образов с помощью Dockerfile. Этим список таких инструкций не исчерпывается. В частности, мы не рассмотрели здесь такие инструкции, как USER, ONBUILD, STOPSIGNAL, SHELL и HEALTHCHECK. Вот краткий справочник по инструкциям Dockerfile.

Вероятно, файлы Dockerfile это ключевой компонент экосистемы Docker, работать с которым нужно научиться всем, кто хочет уверенно чувствовать себя в этой среде. Мы ещё вернёмся к разговору о них в следующий раз, когда будем обсуждать способы уменьшения размеров образов.

В образ контейнера, поверх базового образа, можно добавлять дополнительные слои. Делается это в соответствии с инструкциями из Dockerfile. Например, если Dockerfile описывает образ, который планируется использовать для решения задач машинного обучения, то в нём могут быть инструкции для включения в промежуточный слой такого образа библиотек NumPy, Pandas и Scikit-learn.

И, наконец, в образе может содержаться, поверх всех остальных, ещё один тонкий слой, данные, хранящиеся в котором, поддаются изменению. Это небольшой по объёму слой, содержащий программу, которую планируется запускать в контейнере.


## Репозиторий контейнеров "Docker Hub"

Если вы хотите дать возможность другим людям создавать контейнеры на основе вашего образа, вы можете отправить этот образ в облачное хранилище. Самым крупным подобным хранилищем является репозиторий Docker Hub. Он используется при работе с Docker по умолчанию. В одной из следующих тем мы подробнее познакомимся с этим сервисом.


## Термины экосистемы Docker

Я разбил термины, с которыми вы можете столкнуться в ходе работы с Docker, на две части. Думаю, это облегчит их запоминание. Первый блок терминов будет относиться к механизмам Docker. Второй — к средствам масштабирования решений, основанных на контейнерах.

###Механизмы Docker

Платформа Docker (Docker Platform) — это программа, которая даёт нам возможность упаковывать приложения в контейнеры и запускать их на серверах. Платформа Docker позволяет помещать в контейнеры код и его зависимости. Как результат, системы, основанные на контейнерах, легко масштабировать, так как контейнеры можно переносить и воспроизводить.

###Движок Docker

Движок Docker (Docker Engine) — это клиент-серверное приложение. Компания Docker разделила движок Docker на два продукта. Docker Community Edition (CE) — это бесплатное ПО, во многом основанное на опенсорсных инструментах.
Вероятно, вы будете пользоваться именно этой версией Docker. Docker Enterprise — это платная версия системы, дающая пользователям дополнительные возможности в области поддержки систем, управления ими и безопасности. Платная версия Docker даёт компании средства, необходимые для её существования.

###Клиент Docker

Клиент Docker и другие механизмы экосистемы (взято из документации) 
Клиент Docker (Docker Client) это основное средство, которое используют для взаимодействия с Docker. Так, при работе с интерфейсом командной строки Docker (Docker Command Line Interface, CLI), в терминал вводят команды, начинающиеся с ключевого слова docker, обращаясь к клиенту. Затем клиент использует API Docker для отправки команд демону Docker.

###Демон Docker

Демон Docker (Docker Daemon) — это сервер Docker, который ожидает запросов к API Docker. Демон Docker управляет образами, контейнерами, сетями и томами.

###Тома Docker

Тома Docker (Docker Volumes) представляют собой наиболее предпочтительный механизм постоянного хранения данных, потребляемых или производимых приложениями.

####Реестр Docker

Реестр Docker (Docker Registry) представляет собой удалённую платформу, используемую для хранения образов Docker. В ходе работы с Docker образы отправляют в реестр и загружают из него. Подобный реестр может быть организован тем, кто пользуется Docker. Кроме того, поставщики облачных услуг могут поддерживать и собственные реестры. Например, это касается AWS и Google Cloud.

###Хаб Docker

Хаб Docker (Docker Hub) — это самый крупный реестр образов Docker. Кроме того, именно этот реестр используется при работе с Docker по умолчанию. Пользоваться хабом Docker можно бесплатно.

###Репозиторий Docker

Репозиторием Docker (Docker Repository) называют набор образов Docker, обладающих одинаковыми именами и разными тегами. Теги — это идентификаторы образов.
Обычно в репозиториях хранятся разные версии одних и тех же образов. Например, Python — это имя популярнейшего официального репозитория Docker на хабе Docker. А вот `Python:3.7-slim` — это версия образа с тегом `3.7-slim` в репозитории Python. В реестр можно отправить как целый репозиторий, так и отдельный образ.
Теперь поговорим о терминах экосистемы Docker, имеющих отношение к масштабированию.
Масштабирование решений, основанных на контейнерах
Следующие четыре термина имеют отношение к одновременному использованию нескольких контейнеров.

###Сеть Docker

Сеть Docker (взято из документации)
Сетевые механизмы Docker (Docker Networking) позволяют организовывать связь между контейнерами Docker. Соединённые с помощью сети контейнеры могут выполняться на одном и том же хосте или на разных хостах. Подробности о сетевой подсистеме Docker можно почитать здесь.

###Docker Compose

Docker Compose — это инструмент, который упрощает развёртывание приложений, для работы которых требуется несколько контейнеров Docker. Docker Compose позволяет выполнять команды, описываемые в файле docker-compose.yml. Эти команды можно выполнять столько раз, сколько потребуется. Интерфейс командной строки Docker Compose упрощает взаимодействие с многоконтейнерными приложениями. Этот инструмент устанавливается при установке Docker.

###Краткий перечень терминов

Давайте, буквально в двух словах, повторим только что представленные вам термины:

1. Платформа Docker — ПО, благодаря которому можно работать с контейнерами.
2. Движок Docker — клиент-серверное приложение (CE или Enterprise).
3. Клиент Docker — программа, которая позволяет взаимодействовать с демоном Docker посредством CLI.
4. Демон Docker — сервер Docker, отвечающий за управление ключевыми механизмами системы.
5. Тома Docker — хранилище информации, используемое в контейнерах.
6. Реестр Docker — удалённое хранилище образов.
7. Хаб Docker — самый крупный реестр Docker, используемый по умолчанию.
8. Репозиторий — коллекция образов Docker с одним и тем же именем.

####Масштабирование:

Сетевая подсистема Docker — среда, которая позволяет организовывать взаимодействие контейнеров.

Docker Compose — технология, упрощающая работу с многоконтейнерными приложениями.

Docker Swarm — средство для управления развёртыванием контейнеров.

Сервисы Docker — контейнеры в продакшне.

Выше мы говорили о том, что рассмотрим дюжину терминов экосистемы Docker, сравнивая их с дюжиной пончиков. Мы рассмотрели уже 12 терминов, и, казалось бы, на этом можно и остановиться. Но мы, на всякий случай, добавим в наш список ещё один термин.

Этот термин относится не к самой платформе Docker, а к технологии, которая очень часто используется совместно с Docker.

Docker можно запускать локально на Linux, Mac и Windows. Если вы пользуетесь Mac или Windows, вы можете установить свежую версию Docker Desktop отсюда. Вместе с этой программой, кстати, устанавливается и Kubernetes. Если вы устанавливаете Docker на другой платформе, то загляните сюда для того, чтобы найти подходящую версию.


####Образы Docker

Вспомните о том, что контейнер Docker это образ Docker, вызванный к жизни. Это самодостаточная операционная система, в которой имеется только самое необходимое и код приложения. Образы Docker являются результатом процесса их сборки, а контейнеры Docker это выполняющиеся образы. В самом сердце Docker находятся файлы Dockerfile. Подобные файлы сообщают Docker о том, как собирать образы, на основе которых создаются контейнеры.

Каждому образу Docker соответствует файл, который называется Dockerfile. Его имя записывается именно так без расширения. При запуске команды docker build для создания нового образа подразумевается, что Dockerfile находится в текущей рабочей директории. Если этот файл находится в каком-то другом месте, его расположение можно указать с использованием флага -f.

Контейнеры, как мы выяснили в первом материале этой серии, состоят из слоёв. Каждый слой, кроме последнего, находящегося поверх всех остальных, предназначен только для чтения. Dockerfile сообщает системе Docker о том, какие слои и в каком порядке надо добавить в образ.

Каждый слой, на самом деле, это всего лишь файл, который описывает изменение состояния образа в сравнении с тем состоянием, в котором он пребывал после добавления предыдущего слоя. В Unix, кстати, практически всё что угодно — это файл.

Базовый образ — это то, что является исходным слоем (или слоями) создаваемого образа. Базовый образ ещё называют родительским образом.
Базовый образ — это то, с чего начинается образ Docker. Когда образ загружается из удалённого репозитория на локальный компьютер, то физически скачиваются лишь слои, которых на этом компьютере нет. Docker стремится экономить пространство и время путём повторного использования существующих слоёв.
 
Изучаем Docker: команды
Сегодняшняя часть цикла материалов по Docker, перевод которого мы публикуем, посвящена командам Docker. Документация Docker содержит подробнейшее описание великого множества команд, но тот, кто только начинает работу с этой платформой, может в них и потеряться, поэтому здесь приведены почти два десятка самых важных команд для работы с Docker. Продолжая сложившуюся традицию, мы сравним команды с россыпью ягод.
Обзор

Давайте вспомним о том, что образы Docker создают на основе файлов Dockerfile, описывающих всё то, что нужно для сборки образов. Кроме того, не будем забывать и о том, что контейнер — это образ Docker, вызванный к жизни. Для того чтобы эффективно пользоваться командами Docker, в первую очередь нужно выяснить — с чем вы имеете дело — с образом или с контейнером. Если подумать об образах и контейнерах, то можно понять, что образ Docker может либо существовать, либо не существовать. То же самое можно сказать и о контейнерах Docker. Существующий контейнер Docker, кроме того, может пребывать либо в работающем, либо в неработающем состоянии.

После того, как вы выяснили, с чем именно вам нужно работать, вы можете найти подходящую команду. Общие сведения о командах Docker

Вот кое-что, о чём полезно знать тем, кто хочет работать с Docker:
Команды интерфейса командной строки Docker, используемые для управления чем-либо, начинаются с ключевого слова docker, за которым идёт пробел, затем идёт указание на то, на что именно будет направлена некая команда, потом ещё один пробел, а потом следует сама команда. Например, именно так построена такая команда: docker container stop.
Если команда направлена на конкретный образ или контейнер, то в ней используется имя или идентификатор такого образа или контейнера.
Например, команда docker container run my_app — это команда для создания и запуска контейнера с именем my_app. В примерах, которые будут приведены ниже, контейнеры мы будем называть my_container, образы — my_image, теги — my_tag, и так далее.
Сначала мы будем рассматривать саму команду, потом — флаги, которые можно с ней использовать, если такие флаги существуют. Если перед флагом стоит два тире — то это его полная форма, флаг с одним тире — это сокращённый вариант некоего флага. Действуют они одинаково. Например, -p это сокращённая форма флага --port.
Цель этого материала заключается в том, чтобы дать вам общие сведения о командах Docker. Так вы, имея общее представление о них и зная о возможностях платформы, доступных благодаря этим командам, сможете, при необходимости, найти подробные сведения о них. Команды, о которых пойдёт речь, испытаны на ОС семейства Linux с использованием движка Docker версии 18.09.1 и API версии 1.39.
Примечание о командах, поддерживаемых Docker CLI 1.13
В интерфейсе командной строки Docker версии 1.13 представлены обновлённые, логически сгруппированные команды. При этом старые команды всё ещё работают, но новыми пользоваться легче, особенно — начинающим. Речь идёт, например, о том, что в версии 1.12 использовалась команда вида docker create, а в версии 1.13 стала доступна команда docker container create. Сведения о соответствии старых и новых команд можно найти здесь.
Сначала мы посмотрим на команды, предназначенные для управления контейнерами, затем обсудим управление образами.

Команды для управления контейнерами
Общая схема команд для управления контейнерами выглядит так:

docker container my_command

Вот команды, которые могут быть подставлены туда, где мы использовали my_command:
create — создание контейнера из образа.
start — запуск существующего контейнера.
run — создание контейнера и его запуск.
ls — вывод списка работающих контейнеров.
inspect — вывод подробной информации о контейнере.
logs — вывод логов.
stop — остановка работающего контейнера с отправкой главному процессу контейнера сигнала SIGTERM, и, через некоторое время, SIGKILL.
kill — остановка работающего контейнера с отправкой главному процессу контейнера сигнала SIGKILL.
rm — удаление остановленного контейнера.


Команды для управления образами

Для управления образами используются команды, которые выглядят так:

docker image my_command

Вот некоторые из команд этой группы:
build — сборка образа.
push — отправка образа в удалённый реестр.
ls — вывод списка образов.
history — вывод сведений о слоях образа.
inspect — вывод подробной информации об образе, в том числе — сведений о слоях.
rm — удаление образа.


Разные команды
docker version — вывод сведений о версиях клиента и сервера Docker.
docker login — вход в реестр Docker.
docker system prune — удаление неиспользуемых контейнеров, сетей и образов, которым не назначено имя и тег.

Теперь рассмотрим эти команды подробнее.
Контейнеры
Начало существования контейнера

На начальном этапе работы с контейнерами используются команды create, start и run. Они применяются, соответственно, для создания контейнера, для его запуска, и для его создания и запуска.

Вот команда для создания контейнера из образа:

docker container create my_repo/my_image:my_tag

В следующих примерах конструкция my_repo/my_image:my_tag будет сокращена до my_image.
Команда create принимает множество флагов. Например, её можно записать в таком виде:

docker container create -a STDIN my_image

Флаг -a представляет собой краткую форму флага --attach. Этот флаг позволяет подключить контейнер к STDIN, STDOUT или STDERR.
После того, как контейнер создан, его можно запустить следующей командой:
docker container start my_container
Обратите внимание на то, что сослаться на контейнер в команде можно либо используя его ID, либо имя.
Теперь взглянем на команду, которая позволяет создать и запустить контейнер:
docker container run my_image

Эта команда тоже способна принимать множество аргументов командной строки. Рассмотрим некоторые из них на примере такой конструкции:


docker container run -i -t -p 1000:8000 --rm my_image

Флаг –i это сокращение для --interactive. Благодаря этому флагу поток STDIN поддерживается в открытом состоянии даже если контейнер к STDIN не подключён.
Флаг -t — это сокращение для --tty. Благодаря этому флагу выделяется псевдотерминал, который соединяет используемый терминал с потоками STDIN и STDOUT контейнера.
Для того чтобы получить возможность взаимодействия с контейнером через терминал нужно совместно использовать флаги -i и -t.
Флаг -p представляет собой сокращение для --port. Порт — это интерфейс, благодаря которому контейнер взаимодействует с внешним миром. Конструкция 1000:8000 перенаправляет порт Docker 8000 на порт 1000 компьютера, на котором выполняется контейнер. Если в контейнере работает некое приложение, способное выводить что-то в браузер, то, для того, чтобы к нему обратиться, в нашем случае можно перейти в браузере по адресу localhost:1000.
Флаг --rm автоматически удаляет контейнер после того, как его выполнение завершится.
Рассмотрим ещё некоторые примеры команды run:

docker container run -it my_image my_command

В подобной конструкции может применяться команда sh, которая создаст сессию терминала в контейнере, с которой можно взаимодействовать через ваш терминал. При работе с образами, основанными на Alpine, лучше ориентироваться на использование sh а не bash, так как в этих образах, по умолчанию, оболочка bash не установлена. Для выхода из интерактивной сессии воспользуйтесь командой exit.
Обратите внимание на то, что здесь мы скомбинировали флаги -i и -t в -it.
Вот ещё один пример работы с командой run:

docker container run -d my_image

Флаг -d — это сокращение для --detach. Эта команда запускает контейнер в фоновом режиме. Это позволяет использовать терминал, из которого запущен контейнер, для выполнения других команд во время работы контейнера.

Проверка состояния контейнера

Если у вас имеются запущенные контейнеры Docker и вы хотите узнать о том, что это за контейнеры, вам понадобится вывести их список. Сделать это можно такой командой:

docker container ls

Эта команда выводит список выполняющихся контейнеров и снабжает этот список некоторыми полезными сведениями о них. Вот ещё один пример этой команды:
docker container ls -a -s

Ключ -a этой команды — это сокращение для --all. Благодаря использованию этого ключа можно вывести сведения обо всех контейнерах, а не только о выполняющихся.

Ключ -s — это сокращение для --size. Он позволяет вывести размеры контейнеров.

Вот команда, которая выводит подробные сведения о контейнере:


docker container inspect my_container

Вот команда, выводящая логи контейнера:


docker container logs my_container


▍Завершение работы контейнера

Иногда работающий контейнер надо остановить. Для этого используется такая команда:


docker container stop my_container 

Она позволяет останавливать работающие контейнеры, позволяя им корректно завершить работу. У контейнера есть, по умолчанию, 10 секунд, на то, чтобы завершить работу.

Если же контейнер нужно остановить быстро, не заботясь о корректном завершении его работы, можно воспользоваться такой командой:


docker container kill my_container

Команда kill, если сравнить работающий контейнер с включенным телевизором, напоминает выключение телевизора путём отключения его от электричества. Поэтому, в большинстве ситуаций, для остановки контейнеров рекомендуется использовать команду stop.

Вот команда, которая позволяет быстро остановить все работающие контейнеры:


docker container kill $(docker ps -q) 

Для удаления остановленного контейнера можно воспользоваться такой командой:


docker container rm my_container

Вот команда, которая позволяет удалить все контейнеры, которые на момент вызова этой команды не выполняются:


docker container rm $(docker ps -a -q)

Подведём итоги этого раздела. Сначала контейнер создают, потом его запускают, или комбинируют эти два шага, используя команду вида docker run my_container. После этого запускается контейнеризированное приложение.

Потом контейнер останавливают командой docker stop my_container. Для удаления контейнера используется команда docker rm my_container.

Поговорим теперь о командах, используемых для работы с образами, с теми самыми шаблонами, из которых создают контейнеры.


Образы


▍Создание образов

Вот команда, которая позволяет собирать образы Docker:


docker image build -t my_repo/my_image:my_tag .

В данном случае создаётся образ с именем my_image, при его сборке используется файл Dockerfile, находящийся по указанному пути или URL.

Флаг -t — это сокращение для --tag. Он указывает Docker на то, что создаваемому образу надо назначить предоставленный в команде тег. В данном случае это my_tag.

Точка в конце команды указывает на то, что образ надо собрать с использованием файла Dockerfile, находящегося в текущей рабочей директории.

После того, как образ собран, его можно отправить в удалённый реестр. Благодаря этому им смогут воспользоваться другие люди, его можно будет загрузить и запустить на другом компьютере. Предположим, вы хотите использовать Docker Hub. Если так — вам понадобится завести там учётную запись. Пользоваться этим ресурсом можно бесплатно.

После того, как вы зарегистрируетесь на Docker Hub, вам нужно войти в систему. И хотя команда, которая для этого используется, напрямую к командам, предназначенным для работы с образами, не относится, её полезно будет рассмотреть именно здесь. Речь идёт о следующей команде:


docker login

Она позволяет войти в учётную запись на Docker Hub. Для входа в систему вам понадобится ввести имя пользователя и пароль.

После входа в систему можно будет отправлять образы в реестр. Делается это так:


docker image push my_repo/my_image:my_tag

Теперь, когда у вас наберётся несколько образов, вы можете их исследовать с помощью специальных команд.


▍Исследование образов

Вот команда, которая выводит список образов, выводя, в том числе, и сведения об их размере:


docker image ls

Следующая команда позволяет вывести сведения о промежуточных образах, входящих в состав образа, в частности — данные об их размерах и о том, как они были созданы:


docker image history my_image

Вот команда, которая выводит подробные сведения об образе, в том числе — данные о слоях, из которых состоит образ:


docker image inspect my_image

Если вы создадите очень много образов, может случиться так, что некоторые из них понадобится удалить.


▍Удаление образов

Вот команда, которая позволяет удалить указанный образ:


docker image rm my_image

Если образ хранится в удалённом репозитории, он оттуда удалён не будет.

Вот команда, которая позволяет удалить все локальные образы:


docker image rm $(docker images -a -q) 

Пользоваться этой командой стоит с осторожностью, но надо заметить, что при её использовании образы, хранящиеся в удалённом репозитории, удалены не будут. В этом заключается одно из преимуществ хранения образов в репозиториях.

Мы рассмотрели основные команды, используемые для управления контейнерами и образами. Поговорим теперь ещё о некоторых командах.


Разные команды

Вот команда, которая выводит сведения о версиях клиента и сервера Docker:


docker version

Эта, уже известная вам команда, применяется для входа в реестр Docker:


docker login

Такая команда позволяет удалить неиспользуемые контейнеры, сети и образы, которым не назначено имя и тег:

docker system prune

Вот пример её использования:

docker system prune -a --volumes

Ключ -a — сокращение для --all, позволяет удалить неиспользуемые образы, а не только те, которым не назначено имя и тег.

Ключ --volumes позволяет удалить неиспользуемые тома.



Итоги

В этом материале мы рассмотрели полезные команды Docker. Если вы только начинаете работать с Docker, то вам стоит обратить внимание на три следующих важнейших команды:

Создание и запуск контейнера:


docker container run my_image

Сборка образа:


docker image build -t my_repo/my_image:my_tag .

Отправка образа в удалённый репозиторий:


docker image push my_repo/my_image:my_tag

Для того чтобы посмотреть справку по командам Docker, можете выполнить в терминале команду docker. Здесь можно найти справочные материалы по интерфейсу командной строки Docker.

В следующий раз мы поговорим о работе с данными в Docker.
 
 работа с данными
В сегодняшней части перевода серии материалов о Docker мы поговорим о работе с данными. В частности — о томах Docker. В этих материалах мы постоянно сравнивали программные механизмы Docker с разными съедобными аналогиями. Не будем отходить от этой традиции и здесь. Данные в Docker пусть будут специями. В мире существует множество видов специй, а в Docker — множество способов работы с данными. Обратите внимание на то, что этот материал подготовлен с использованием движка Docker версии 18.09.1 и API версии 1.39.

Данные в Docker могут храниться либо временно, либо постоянно. Начнём с временных данных.

Временное хранение данные

В контейнерах Docker организовать работу с временными данными можно двумя способами.

По умолчанию файлы, создаваемые приложением, работающим в контейнере, сохраняются в слое контейнера, поддерживающем запись. Для того чтобы этот механизм работал, ничего специально настраивать не нужно. Получается дёшево и сердито. Приложению достаточно просто сохранить данные и продолжить заниматься своими делами. Однако после того как контейнер перестанет существовать, исчезнут и данные, сохранённые таким вот нехитрым способом.

Для хранения временных файлов в Docker можно воспользоваться ещё одним решением, подходящим для тех случаев, когда требуется более высокий уровень производительности, в сравнении с тем, который достижим при использовании стандартного механизма временного хранения данных. Если вам не нужно, чтобы ваши данные хранились бы дольше, чем существует контейнер, вы можете подключить к контейнеру tmpfs — временное хранилище информации, которое использует оперативную память хоста. Это позволит ускорить выполнение операций по записи и чтению данных.

Часто бывает так, что данные нужно хранить и после того, как контейнер прекратит существовать. Для этого нам пригодятся механизмы постоянного хранения данных.

Постоянное хранение данных

Существуют два способа, позволяющих сделать срок жизни данных большим срока жизни контейнера. Один из способов заключается в использовании технологии bind mount. При таком подходе к контейнеру можно примонтировать, например, реально существующую папку. Работать с данными, хранящимися в такой папке, смогут и процессы, находящиеся за пределами Docker. Вот как выглядят монтирование tmpfs и технология bind mount.

 

Монтирование tmpfs и bind mount
Минусы использования технологии bind mount заключаются в том, что её использование усложняет резервное копирование данных, миграцию данных, совместное использование данных несколькими контейнерами. Гораздо лучше для постоянного хранения данных использовать тома Docker.

###Тома Docker

Том это файловая система, которая расположена на хост-машине за пределами контейнеров. Созданием и управлением томами занимается Docker. Вот основные свойства томов Docker:
•	Они представляют собой средства для постоянного хранения информации.
•	Они самостоятельны и отделены от контейнеров.
•	Ими могут совместно пользоваться разные контейнеры.
•	Они позволяют организовать эффективное чтение и запись данных.
•	Тома можно размещать на ресурсах удалённого облачного провайдера.
•	Их можно шифровать.
•	Им можно давать имена.
•	Контейнер может организовать заблаговременное наполнение тома данными.
•	Они удобны для тестирования.

Как видите, тома Docker обладают замечательными свойствами. Давайте поговорим о том, как их создавать.

###Создание томов

Тома можно создавать средствами Docker или с помощью запросов к API.
Вот инструкция в Dockerfile, которая позволяет создать том при запуске контейнера.

`VOLUME /my_volume`

При использовании подобной инструкции Docker, после создания контейнера, создаст том, содержащий данные, которые уже имеются в указанном месте. Обратите внимание на то, что если вы создаёте том с использованием Dockerfile, это не освобождает вас от необходимости указать точку монтирования тома.

Создавать тома в Dockerfile можно и используя формат JSON.
Кроме того, тома можно создавать средствами командной строки во время работы контейнера.
Работа с томами из командной строки

Создать самостоятельный том можно следующей командой:
`docker volume create —-name my_volume`

Выяснение информации о томах
Для того чтобы просмотреть список томов Docker, воспользуйтесь следующей командой:
`docker volume ls`

Исследовать конкретный том можно так:
`docker volume inspect my_volume`

Удалить том можно следующей командой:
`docker volume rm my_volume`

Для того чтобы удалить все тома, которые не используются контейнерами, можно прибегнуть к такой команде:
docker volume prune

Перед удалением томов Docker запросит у вас подтверждение выполнения этой операции.
Если том связан с каким-либо контейнером, такой том нельзя удалить до тех пор, пока не удалён соответствующий контейнер. При этом, даже если контейнер удалён, Docker не всегда это понимает. Если это случилось можете воспользоваться следующей командой:

`docker system prune`

Она предназначена для очистки ресурсов Docker. После выполнения этой команды у вас должна появиться возможность удалить тома, статус которых до этого определялся неправильно.

Флаги `--mount` и `--volume`

Для работы с томами вам, при вызове команды docker, часто придётся пользоваться флагами. Например, для того чтобы создать том во время создания контейнера можно воспользоваться такой конструкцией:

`docker container run --mount source=my_volume, target=/container/path/for/volume my_image`

В давние времена (до 2017 года) популярен был флаг `--volume`. Изначально этот флаг (ещё им можно пользоваться в сокращённом виде, тогда он выглядит как -v) использовался для самостоятельных контейнеров, а флаг `--mount` — в среде Docker Swarm. Однако, начиная с Docker 17.06, флаг --mount можно использовать в любых сценариях.

Надо отметить, что при использовании флага `--mount` увеличивается объём дополнительных данных, которые приходится указывать в команде, но, по нескольким причинам, лучше использовать именно этот флаг, а не --volume. Флаг `--mount` — это единственный механизм, который позволяет работать с сервисами или указывать параметры драйвера тома. Кроме того, работать с этим флагом проще.

В существующих примерах команд, направленных на работу с данными в Docker, вы можете встретить множество примеров употребления флага -v. Пытаясь адаптировать эти команды для себя, учитывайте то, что флаги `--mount` и --volume используют различные форматы параметров. То есть, нельзя просто заменить -v на --mount и получить рабочую команду.

Главное различие между `--mount` и `--volume` заключается в том, что при использовании флага `--volume` все параметры собирают вместе, в одном поле, а при использовании `--mount` параметры разделяются.

При работе с `--mount` параметры представлены как пары вида ключ-значение, а именно, это выглядит как key=value. Эти пары разделяют запятыми. Вот часто используемые параметры `--mount`:


Type – тип монтирования. Значением для соответствующего ключа могут выступать `bind`, `volume` или `tmpfs`. Мы тут говорим о томах, то есть — нас интересует значение volume.
source — источник монтирования. Для именованных томов это — имя тома. Для неименованных томов этот ключ не указывают. Он может быть сокращён до src.
destination — путь, к которому файл или папка монтируется в контейнере. Этот ключ может быть сокращён до dst или target.
readonly — монтирует том, который предназначен только для чтения. Использовать этот ключ необязательно, значение ему не назначают.

Вот пример использования --mount с множеством параметров:
`docker run --mount type=volume,source=volume_name,destination=/path/in/container,readonly my_image`

Вот полезные команды, которыми можно пользоваться при работе с томами Docker:
`docker volume create`
`docker volume ls`
`docker volume inspect`
`docker volume rm`
`docker volume prune`

Вот список часто используемых параметров для `--mount`, применимых в команде вида `docker run --mount my_options my_image`:

`type=volume`
`source=volume_name`
`destination=/path/in/container`
`readonly`



## Основное предназначение – это проведение тестирования при разработке программного обеспечения.
### Сущности

Перед изучением Docker команд стоит сначала разобраться с сущностями, с которыми работает соответствующая «технология». Всего их несколько:
Docker Image. Это – образ. Представляет собой шаблон, по которому создаются контейнеры. Можно сравнить со слоеным пирогом: поверх «базы» накладывается файловая система. На выходе получается готовый неизменный образ. Он позволяет устанавливать утилиты, конфигурации и зависимости. Другие образы могут наследоваться в Docker Images.

### DockerFile

Файл, в котором описаны основные инструкции относительно сборки образов.
### Docker контейнер

Представляет собой контейнер. Runtime-сущность, которая опирается на образ. Приложение, развернутое через рассматриваемую «технологию». Здесь образ – это инсталлятор. У запущенных контейнеров аналогия – уже активированная программа.
### Registry

Репозиторий, в котором будут храниться образы Докера. Может быть публичным или локальным. Репозитории создаются на платформах типа GitLab, в них размещают images с описаниями, а также тегами и разного рода версиями.

Все это необходимо помнить перед тем, как изучать основные Docker команды. Разобраться с соответствующим направлением на самом деле не так трудно, как может показаться. Даже новичок в программировании со временем сможет быстро освоить контейнеры и навыки работы с ними.

## У Docker есть следующие компоненты:

host – операционная система, на которую устанавливается «технология»;
daemon – служба управления объектами Докера: хранилищами, сетями, контейнерами и образами;
client – консольный клиент, который дает возможность взаимодействовать с daemon, отправлять команды, создавать контейнеры и контактировать с ними;
image – неизменяемый образ, из которого будет разворачиваться заданный контейнер;
container – развернутое и запущенное ПО;
registry (Docker Hub) – репозиторий, который хранит образы;
dockerfile – инструкция по сборке образа;
compose – инструмент для управления несколькими контейнерами;
desktop – GUI-клиент, который распространяется через GPL.
Теперь можно изучать Docker команды, которые помогут грамотно управлять образами и контейнерами, а также проводить тестирование. Автоматизированное в том числе.
Dockerfile. Текстовый файл с последовательно расположенными инструкциями для создания образа Docker. Файл создаётся по принципу «одна строка — одна команда».

**Daemon**. Фоновая служба на хосте, которая отвечает за создание, запуск и уничтожение контейнеров.

**Image**. Неизменяемый файл (образ), из которого можно неограниченное количество раз развернуть контейнер.

**Client**. Утилита командной строки в Docker для управления демоном. Любое взаимодействие с контейнером проходит через Daemon.

**Container**. Запущенное приложение, которое развернули из образа.

**Registry**. Служба в Docker, выполняющая функции репозитория (хранилища). Позволяет следить за версиями образов, создавать приватные репозитории.

**Docker Hub**. Популярный публичный репозиторий, используемый по умолчанию в Docker. Обеспечивает интеграцию с GitHub и BitBucket.

**Docker Desktop**. Приложение, позволяющее локально собирать, выполнять и тестировать контейнеры. Работает на Windows и macOS.

**Docker volumes**. Тома для постоянного хранения информации. По умолчанию в Docker папки хранилищ создаются на хост-машине, но предусмотрена и возможность подключения удаленных хранилищ. Использование томов позволяет лучшим образом настроить хранение данных.
### Недостатки Docker
Но сначала стоит выяснить, какие минусы есть у докеров и контейнеров. Может быть, программисту стоит обратить внимание на виртуальные машины для организации тестинга.
К минусам «системы» относят:
Высокие требования к ресурсам задействованного устройства. Докеры создают дополнительную логическую прослойку в системе. Это влечет повышенную нагрузку на девайс.
Необходимость использования оркестратора. Этот момент, связанный с контейнером, необходимо учитывать относительно крупных утилит. Docker годится для запуска сразу нескольких «хранилищ».
Проблемы при инициализации на MacOS и Windows. Это связано с тем, что изначально «технология» была создана под Линукс. Некоторые типы сетей в Docker не поддерживаются.
 Отныне каждый сможет оценить, насколько соответствующая «технология» ему подходит. Можно изучать ключевые Docker команды.
Существующие основные алгоритмы

Докер – идеальный инструмент для создания микросервисов, позволяющий работать с облачными утилитами и системами. Чтобы им пользоваться, требуется активировать терминал. В нем прописываются инструкции и указания системе.

### Основные Docker команды, которые должен знать как новичок, так и опытный разработчик:
| Команда     | Описание  |
| ----------- | --------- |
| **docker ps** | Отображает список  контейнеров запущенных в текущий момент. Среди флагов используют: **-a/** **-all** – все контейнеры (включая остановленные). По умолчанию ведется показ всех контейнеров. **-q/** **-quiet** – перечислить только id контейнеров. |
| **docker pull** | Позволяет скачать определенный образ или набор images (репозиториев).|
| **docker build** | Команда, которая будет собирать докер из Dockerfile, а также имеющегося контекста. Последний – это набор документов, который расположен по определенному пути или URL. Флаг –t позволяет задать имя.|
| **docker run**  | Операция, которая отвечает за запуск контейнера.  Может дополняться другими Docker командами. |
| **docker logs** | Применяется для того, что просматривать логи указанного контейнера. При помощи флага –follow ведется за слежкой работающей утилиты.|
| **volume ls** | Отображение списка томов, которые предпочтительны для сохранения информации. |
| **docker rm** |Удаление одного или более контейнеров. |
| **docker rmi** |Стирание одного или более образов. |
| **docker stop** | Это – остановка контейнеров. Можно прекратить работу одного или нескольких «хранилищ».|
| **docker kill** | Удаление контейнеров. |
| **docker pull** | Выгрузка образа из реестра. |
| **docker login** | Команда, которая позволяет подключиться к серверу. То есть, войти в систему. |

 
 
### Dockerfile - cоздание образов
#### Какие команды используются при создании Docker образов 
Инструкции которые используют в Dockerfile для создания и настройки образа Docker. Вот некоторые из наиболее распространенных:
- **FROM**: указывает базовый образ для использования в качестве нового образа. Обычно это первая инструкция в Dockerfile.
- **RUN**: запускает команду или серию команд в контейнере для установки зависимостей, настройки параметров или выполнения других задач.
- **COPY** или **ADD**: Копирует файлы из хост-системы в контейнер.
- **ENV**: устанавливает переменные среды для контейнера.
- **WORKDIR**: устанавливает рабочий каталог для контейнера.
- **EXPOSE**: открывает порт для контейнера.
- **CMD**: указывает команду по умолчанию для запуска при запуске контейнера.

Эти инструкции можно использовать в различных комбинациях для создания образа Docker, соответствующего вашим требованиям. Точные инструкции и конфигурация будут зависеть от вашего конкретного случая использования и приложения.
 
## Преимущества использования Docker
Какие преимущества Docker приносит компаниям и разработчикам?

- Гибкость и адаптивность. Благодаря Docker можно легко запускать контейнер в облачной инфраструктуре и на любом локальном устройстве. Можно создать базовые шаблоны контейнеров и использовать повторно. Простая переносимость и простота развертывания также являются важными преимуществами этой технологии.
- Меньше ошибок и противоречий (конликтов) окружений. В контейнерах Docker содержится всё, что требуется для запуска приложения, поэтому перенос приложений из одной среды в другую не вызывает затруднений. Исчезает проблема, когда у разработчиков всё функционирует как надо, а на боевом сервере — нет.
- Скорость развертывания. Так как настраивать окружение для разработки, тестирования и боевого режима больше не нужно, время развертывания сокращается в несколько раз.
Рост универсальности. Docker позволяет использовать любые языки программирования и стек технологий на сервере, избавляя от проблемы несовместимости разных библиотек и технологий.
- Комьюнити и поддержка. Существует огромная библиотека контейнеров с открытым исходным кодом. Можно скачать нужный образ для конкретной задачи или обратиться за помощью к большому комьюнити разработчиков, которые используют Docker.
- Непрерывность работы. С учетом инструментов управления трафиком можно построить процесс обновления приложения так, чтобы обновление одних контейнеров не влияло на работоспособность системы и оказание услуг пользователям.
- Упрощение администрирования. С помощью Docker легче перенести контейнер с одного хоста на другой, запустить сразу несколько образов, обновить группы контейнеров и откатиться к старой версии.
- Повышение уровня безопасности. Контейнеры в Docker частично изолированы друг от друга на уровне процессов и ОС, поэтому запуск большого количества контейнеров на одной машине не несет рисков.
- Экономическая эффективность. Контейнеры легковесны и производительны, а благодаря использованию Docker можно эффективнее управлять имеющимися ресурсами и сократить расходы компании.
- Современный подход. Отказ от монолитной архитектуры в пользу микросервисной позволяет более гибко развивать продукт, добавлять в него новые функции.

## Ссылки на дополнительные материалы

- https://www.freecodecamp.org/news/a-beginner-friendly-introduction-to-containers-vms-and-docker-79a9e3e119b
- https://habr.com/ru/company/ruvds/blog/438796/	
- http://onreader.mdl.ru/UsingDocker/content/Ch04.html#04.4
